/*-------------------------------------------------------------------------------------------------------------*/
VS中 ctrl+K+C快速注释  ctrl+K+U取消注释
1.在VS  IDE中 有个Debug旁边有个x86 x64选项，是控制编译器的编译系统环境，如果是86那么为32位的系统，此时指针占4个字节
，后者指针占8个字节
2.空指针：nullptr或NULL或0；指针变量指向内存中编号为0的空间，用途是初始化指针，空指针指向的内存不可被访问
3.结构体和类的区别就在于默认的属性，前者默认为public，且最好仅存数据，后者为面向对象的类。
创建对象时，可以创建对象数组，比如Student student[3] = {{"d",1,0},{"f",2,1},{"v",3,1}};顺便初始化
4.结构体嵌套结构体：
  结构体的成员可以是另一个结构体  G:\C++Program\黑马程序C++\6 ，比如tea.stu.age = 10;一定指向最低级成员
5.函数占位参数：
C++函数的形参列表中可以使用占位参数，用来占位，调用函数时必须填补该位置，当然占位参数可以有默认参数。
举例：
void fun(int a, int){}//后面一个就是占位参数，调用时必须填补此位置，fun(10,10);将前10传给a，后10填补那个位置；
void fun(int a, int = 10){}//后面一个就是占位参数，具体同上，只不过这里使用了默认占位参数，fun(10);可以这样调用
6.类中的属性又称为 成员变量/成员属性
  类中的行为又称为 函数或方法
7.析构函数不允许有参数，对象结束后 销毁堆区开辟的空间
构造函数：创建对象的时候自动调用（置调用一次）
8.匿名对象：
  在创建带参构造后，比如 类 对象(10);//自动调用相应构造；但是我也可以这样 类 对象 = 类（10）；右侧部分没有对象
  时，称为匿名对象，会将左侧的对象当做其对象，匿名对象会在执行完当前句后，系统立即回收匿名对象
9.类对象可以作为类成员： G:\C++Program\黑马程序C++\16
  C++类中的成员可以是另一个类的对象，我们称该成员为对象成员。
  构造的时候，先构造对象成员，再构造本身，析构时先析构本身，再析构对象成员。
10.静态成员 static
  静态成员就是在成员变量和成员函数前加上static，称为静态成员。又分为：
  静态成员变量：
    A.所有对象共享一份数据，不属于某一个对象————我们知道当类创建对象后，对象所占的空间仅为成员变量所占的空间，函数是所有对象共享的，但变量是各自有一份。static改变了变量的访问，使所有对象共享这一个，对象A改动值，那么对象B的这个值也是改动后的..
    B.在编译阶段分配内存————全局区
    C.类内声明，类外初始化（必须有初始值）==》（二者最好在同一个文件下）
      int Person::m_p = 10; //类外初始化————类型名+ Person::+ 变量；————声明这个变量是类中的所以可以访问私有属性等
    D.因为 静态成员变量不属于某一个对象，所有对象共享一份数据。所有访问的方式有两种：
      一是通过对象进行访问 对象.变量的方式；
      二是通过类名访问， Person::m_p，比如cout<< Person::m_p<<endl;
    E.静态成员变量也是有访问权限的（public private protected），即D中如果静态成员变量定义在非公共区，那么类外不能
    通过Person::m_p进行访问
    {46.访问修饰符：
     public ：修饰的成员在任意地方都可以访问
     private: 修饰的成员只能够在类的内部或者友元函数中访问——(目的是保护数据)，（数据可以被初始化）
     protect: 修饰的成员可以在类中函数、子（派生类）函数以及友元函数中访问}

  静态成员函数：
   A.所有对象共享同一个函数
   B.静态成员函数只能访问静态成员变量
   C.同静态成员变量一样，访问机制也是两种，对象访问或类名访问 p1.fun();或  Person::fun();
  综上：
   A.静态成员不能声明成const以及不能使用this指针（因其不属于任何对象，而this是“这个对象”的指针）
   B.在类中声明静态成员函数时加static，在类外定义时，不用再加；
   C.普通的成员函数不需要通过作用域运算符就可以使用静态成员
   D.和全局变量一样，静态成员一旦定义并初始化后，作用域也为整个函数
   E.静态成员变量也可以在类内定义static constexpr int m_A = 20;//使用constexpr关键字，但是类外一定声明一下，
     constexpr int Person::m_A ; //加上constexpr后就不允许更改了
11.空指针访问成员变量：
   比如 类* 对象= NULL;  对象->方法();此时会报错。因为每个非静态成员里面都有this指针，this指针属于当前的对象，但是
   当前的对象为NULL，所以在方法内不允许出现成员变量。
12.常函数：在函数后面加const
   this的意思是当前对象，就是哪个对象调用，就属于哪个对象。他是本质是  类* const this；即this的本质是指针常量，
   也就是指向的对象的地址不允许改变，但可以改变值，比如this->m_age= 10;//值可变，但this属于当前对象。比如在方法中
   令this = NULL，则会出错，因为this的地址属于“当前对象”，不能随意更改
   在在函数后面加const，本质是 const 类* const this；就是表示成员值也不允许改变
   关键字： mutable
   在常函数中，不能修改成员值，但是当某一个成员变量定义为mutable，则可以在常函数中更改
   常对象： 就是 const 类 对象；
   常对象只能调用常函数
   常对象不能更改成员变量的值，表示只读状态，但是mutable定义的变量，可以在常对象中随意改变
13.友元
    A.类允许其他类和函数访问他的非公有成员，的方法是：令其他类或函数称为他的友元(关键字friend)   
      最好在类的最后或开始出集中的声明友元函数
    B.总结：
    如果希望一个（类外部，就是不使用同一个类）外部的函数或者另一个类，使用本类的非公元成员，那么在本类中集中声明
    这些函数或类，但要加上friend关键字
    在上句的基础上，如果希望类调用外部的函数或类，那么就需要在同一个头文件下，在类的外部，重新声明这些函数或类，
    不需要加friend
    这是一个双向的关系
    友元的三种实现：
      A.全局函数作友元
         就是将某函数（想访问类私有属性的函数），定义在类中的上面即可，这个函数不属于任何类，G:\C++Program\黑马程序C++\19
      B.类作友元
          friend class GoodGay; G:\C++Program\黑马程序C++\20
      C.成员函数作友元
         区分A，此时的函数属于某个类。friend void GoodGay::visit();
         两个类最好在一个文件下定义，且friend void GoodGay::visit();中的GoodGay类一定在另一个类的上面定义，否则
         有错G:\C++Program\黑马程序C++\21
/*-------------------------------------------------------------------------------------------------------------*/ 






1.System("pause");     或者   cin.get();   或者 getchar();    //针对控制台一闪而过的现象，在 IDE 中运行程序时，当程序终止，则输出窗口会关闭，而 这些函数可用于保持输出屏幕可见。
  system("cls"); 清空控制台信息 
2. <iostream>
        io 指 INPUT &OUTPUT;     stream指 流；iostream包含了输入输出相关语句的函数
   <stdio.h>包含了打印printf等，C语言相关语句的函数
   <climits>包含了许多定义，比如INT_MAX（整型的最大值）等等
   <string>定义了string （定义非数值变量）的一些标准  
   <math.h> 等同于 <cmath> 定义诸多数学函数 
           pow(),函数是求平方，立方等，比如pow(π,2) ==>π的平方，pow(π,4)==>π的四次方
           sqrt(数)，根号
           abs(数);整数的绝对值
           fabs(数);浮点的绝对值
   <iomanip>  1.强制以小数的方式显示（对整型不适用）―― cout<< fixed;2. 控制显示的精度――cout<<setprecision(小数的位数即精度);
            setw()函数
   <windows.h> 包含了
           a.SetConsoleTitle("输入");改变控制台标题；――错误解决方法：右键点击当前解决方案→属性→配置属性→字符集→使用多字节字符集
   <cstdlib>(<stdlib.h>)包含了  rand()函数，以及RAND_MAX,srand
             1.rand()和srand函数的用法：――rand()函数用来产生随机数,rand()会返回一个范围在0到RAND_MAX（32767）之间的伪随机数（整数）。
                如果想输出【0，1】之间的数，用rand()/RAND_MAX;想输出【0，100】，则用rand（）%100，如果想输出【100，200】则用rand（）%100 +100；
               但rand（）函数输出的是伪随机数，如果想输出随机数则需要srand()函数，需要介绍另一个函数time（）函数（头文件在<ctime>中）
               time（0）或者time(NULL)可以输出一个与时间有关的数在结合srand()函数即可产生真正的随机数 ，用法srand(time(NULL))   
               用下列公式即可得到指定范围[m,n]的随机数：
               r  = rand()%(n - m + 1) + m;       
   <ctime>
   <vector>
   <algorithm>(中文意思是算法)
      sort(vec1.begin(), vec1.end());升序     <==> sort(起, 始);
      reverse(vec1.begin(), vec1.end());降序  <==> reverse(起, 始);
   <memory.h>
     memset 函数将数组元素全置为某一个数：==》》 memset(数组名，数，sizeof(数组名));
          比如memset(数组名，0，sizeof(数组名)); //数组元素清0
   <string>
      memcpy(新数组名，旧数组名，sizeof(类型)*个数); ==>将旧数组赋值到新的数组中
         比如：memcpy(newarrary，arrary，sizeof(类型)*个数); ==>将旧数组赋值到新的数组中
      strlen()//获取字符串的长度
      strcpy(新数组，旧数组)//复制到新的数组
         如果报错，解决方法：我们可以在项目-属性-配置属性-c/c++-预处理器-预处理定义里边加上一句：_CRT_SECURE_NO_WARNINGS 
      size()
      empty()
   <iterator>
     迭代器,begin(),end()
    <assert.h>
    <toupper> 接受任意单个字符，并转换为大写
    <cctype>  包含若干函数用于处理string类型中的字符，P108 ，C++Primer第五版
3. <<表示把字符串(流到)发送到 cout（在<iostream>中定义）打印（cout类似于屏幕printf）,endl(end line)是控制符，表示重启一行(\n)
4. std是 standard（标准）
5./***********************************************************
  * 文件名 ：
  * 作  者 ：
  * 日  期 ：
  * 描  述 ：
  * 版  本 ：
************************************************************/
6.float 为32位。有效数字仅为6位，即只能显示6个数  ，不适合显示大数，会影响精度，多用double， 在C++中小数默认为double，除非小数结尾以f结尾，为float，比如3.14f   
  const 定义常量，比如 const float PI = 3.14f；    
7. sizeof 用来测量数据类型的长度（单位：字节）;（数据类型占用内存空间的大小）
   sizeof(int) =  4;   sizeof(整数比如3) = 4（默认为整数类型）； sizeof(double) =  8;   sizeof(整数比如0.3) = 8（默认为双精度浮点类型）； 
   sizeof(char) =  1;   sizeof('\n') = 1（默认为字符类型）； 
   sizeof 是运算符，没有运算，比如定义变量a=1;   sizeof(a++) ――结果为 4（字节），但是a仍未1，因为sizeof中没有运算，不管a++
   在32位机中，任何指针大小都是4个字节，sizeof(指针) = 4， 在64位机中，任何指针大小可能是8个字节，也可能是4个字节，这要看编译器
    //数组到底是什么?..........
    //不在sizeof下，数组名就是数组的首地址
    //在sizeof下，数组名就是一个数组的类型，什么是数组的类型？
    //double score[]{11,22,33,44,55};数组的类型就是double[5],所以sizeof(score) = 40
    所以结合 20.  就知道为什么那么求数组个数了；
8. '\a系统蜂鸣器' ' \t制表符（对齐）' ' \n换行'   == "\a"  "\t" "\n"..........
9.setw(数)；为设置宽度，仅作用于后面的一条指令――位于<iomanip> 中，他的作用是方便取代 \t （水平制表符），默认右对齐
  如果想左对齐，加一句cout << left;
  数据对齐后，可以设置填充cout << setfill('任意符号');
10.  在cout输出流中可以用 表达式 但是表达式的操作要用（）；<==>cout << "x += 10的意思为：\t" << (x = x+10)<< '\n';
11. cout << boolalpha;   //将 表达式中的0/1的真假 转换为true/false
12.     &&――两个表达式之间相与， || ――两个表达式之间相或，  ！取反
       &（按位与）――两个操作数之间，     |（按位或），^(按位异或)，<<（左移，右侧空位补0），  >>（右移，左侧空位补符号位）
      ~（按位取反，8位操作） ~2 <==> ~（0000 0010）―― 1111 1101 （为负数，最高位为符号位）――负数二进制转换为10进制的方法为：将二进制取反，然后+1，结果添负号。
13. 三元运算符 ： int num = 5 > 6 ? 10 : 12;  // 5 > 6 ?显示为假，故将12 传给num，若为真则将 10传给num
14. 	char Input = '\0';          //默认值设置为  空字符   <==>好习惯
15.  for(;;)<==>while(1)
16.嵌套循环————外层循环控制行（行数和换行），内层循环控制列（列数和 列的图形个数）。单循环处理直线，嵌套循环处理平面
   打印图案就是找i和j的关系（这句话很重要），   *    诸此图案前都是用空格打印的；
                                               ***
   因为我们的循环（Seven_demo程序）都是从0开始的（行和列的初始i=0，j=0开始），所以计算个数时要从0开始计算
17. 变量：内存中的一块空间；            数组：内存中的一串连续空间
18.在C++中没有真正意义的bool类型，true false其实也是 1    0，所以数组{1,0,true,false,38,-1}是正确的，‘字符’，字符型变量由char定义，char
也属于整型，故{12，0，'c'}也是正确的
19. 数组中的数据必须同一类型;数组的大小一经定义，就不能再更改了
20. seziof(数组名)/seziof(数组类型或者数组的第一个元素) = 数组所占字节数（元素个数）；此方法不适用string类型(如果数组中的字符串都是相同位数的，比如“我”，“你”等可以使用这个方法，如果格式不一样不能使用)，比如
      sizeof(array)/sizeof(array[0]) = 数组的长度
      说明：seziof(数组名)是计算该数组共占多少字节数，seziof(数组类型或者数组的第一个元素)是该数组的长度（字节数），相比为个数

21.冒泡排序：
   外层循环控制轮数（一般为总数-1次），内层循环控制每轮的比较和交换（两两比较）
   选择排序：

22.数组的替代品————向量容器vector（在<vector>头文件中），vector是一个快速的动态分配内存的数组,大小可以动态拓展（是一个模板类）。他是一个动态分配内存的数组
     a.动态数组，可以在运行阶段设置长度；//
     b.具有数组的快速索引方式；//就是查询方式，不亚于数组
     c.可以插入和删除元素；
     定义和初始化：
     a. vector<double> vec1;     //<double> 指这个容器中 只能存放double这一种数据类型  <==>  最常用(比较下两种)
                                  <double> 又称为泛型 
     b. vector<string> vec2(5);  //（5）是指默认给他5个内存空间，由值初始化，根据类型的不同为值初始化，因为此时是
        string类型的对象，那么就会默认为5个空间，都是""（空strng类型），如果类型是int，那么默认是0
     c. vector<int> vec3(20,998);//给他默认20个元素，每个元素都是998
     常用操作：
        clear()                     移除容器中的所有数据
        empty()                     判断容器是否为空，如果空返回true，否则返回false
        capacity();                 容器的容量一定大于或等于 size();

        size()                      返回容器中元素的个数
        [index]、at(index)          返回索引为Index的元素
/**eraset删除元素后指向下一个位置*/
        erase(pos)                  删除pos位置处的数据
        erase(beg,end)              删除  [beg,end)  区间的数据    //例如 vec1.erase(vec1.begin()+1,vec1.begin()+4);
        front()                     返回第一个元素
/**insret返回的插入元素的上一个位置，很重要这句话*/
        insert(pos,elem)            在pos位置处插入一个元素
        insert(pos,n,elem)            在pos位置处插入n个相同的元素
        insert(pos,{elem}})            在pos位置处插入一组元素（比如{1,2,3，4}等）
        insert(pos,b,e)             b 和 e是另一个容器的元素范围，将他们插入到本容器pos处



        pop_back()                  删除最后一个元素
        push_back(elem)             在容器末尾插入一个元素

        resize(num)                 
         * 重新设置容器的长度，若容器变长，则以默认值填充新位置，若变短，则末尾超出长度的元素被删除，但容量不变
        resize(num,elem)  
         * 重新设置容器的长度，若容器变长，则以elem值填充新位置，若变短，则末尾超出长度的元素被删除，但容量不变

        begin()、end()              返回容器首尾元素的迭代器
           begin()返回的是第一个元素的迭代器，但是end()返回的却是末尾元素再下一个元素的迭代器(地址)    ，  注意end并不指向容器的任何元素，而是指向容器的最后元素的下一位置，称为超出末端迭代器。
        //pos位置处 是指 迭代器中的begin()、end() 为开始，比如vec1.insert(vec1.begin(),99.0);在开始处加入一个元素；
        //vec1.insert(vec1.end(),66);在末尾处加入一个元素；
        /***********************************************************************************************
        A. 第一种遍历的方法：
        vector<double>::iterator it;//得到(vector<double>类型的)迭代器对象——实际上是一个指针对象!
        其中vector<double>::iterator it == vector<double>::const_iterator it
        迭代器的作用是遍历数组：
           for(it = 数组名.begin();it != 名.end();++it){cout << *it <<end;//打印数组元素}
        B. 第二种遍历方法：
        vector<double>::iterator it ;这句话太长了，可以用auto进行简化 ，（auto为类型推断）
        省略了vector<double>::iterator it ;这句话
        for(auto it = 数组名.begin();it != 名.end();++it){cout << *it <<end;//打印数组元素}
        C. 第三种遍历方法：
           for区间遍历-C++11才有(第二种也是)
           for(auto 新的数组名:数组名){cout << 新的数组名<<" ,"}
        D. 第四种遍历的方法：
           //使用算法的方式，将容器的内容复制到cout绑定的迭代器中
            需要导入 <algorithm>(中文意思是算法) 和<iterator>头文件
            copy(数组名.cbegin(),数组名.cend(),ostream_iterator<数组类型>(cout,","));
            cout<<endl;
        /***********************************************************************************************
        //vec1.insert(vec1.begin()+1,3,55);在开始+1  即就是在数组第一个位置加入3个 55
23. 指针（Pointer）(ptr)————是一个变量，存储的是另一个变量的内存地址，*意思为从地址中取值的意思（指向），&意思是取地址
24. 空指针不指向任何对象，在使用一个指针之前可以首先检查是否为空；因为使用指针是非常危险的，比如int* num; cout <<num<<endl此时输出的结果是随机的，有可能为系统文件的地址那么此时我*num=数，是很危险的。所以强烈初始化所有指针，并在有可能的情况下，尽量等定义了对象之后，再定义指向他的指针。用法是：
  int* ptr1 = nullptr <==> int* ptr1 = 0; <==> int* ptr1 = NULL(如果使用NULL，则需要调用<cstdlib>)
25. void*指针———— 无类型指针  是一种特殊的指针类型，可以存放任意对象的地址
     double objNum = 3.14;
     double* ptr_objNum = &objNum;
     cout << ptr_objNum << '\n';
     void* vptr_objNum = &objNum;
     cout << vptr_objNum << endl;    //结果一样
         注意：void*指针存放一个内存地址，地址指向的内容是什么类型不能确定；void* 类型指针一般用来：和别的指针比较，作为函数的输入和输出，赋值给另一个void*指针
26.引用：为对象起了另外一个名字（引用就是别名），比如：int num = 100； int& jj = num；//那么就是jj指向num，是num的另一个名字。
   所以jj =90的话，那么num=90。引用必须初始化，其实底层就是指针（上两个语句等同于 int num = 100； int* jj = &num；）
    注意：a.引用并非对象，只是为一个已经存在的对象起别名
    b.引用只能绑定在对象上，不能与字面值或者某个表达式的计算结果绑定在一起，比如int& num = 10//错误，即指向常量的引用是非法的
    c.引用必须初始化
27.指针和数组：以int num[20]为例：
       a. 数组名就是这块连续内存空间的首地址（<==> &数组名[0]），即 num = &num[0]
       b.  数组第i+1个元素可以表示为：
           第i+1个元素的地址为：&num[i+1],num+i+1  ==>第i+1个元素的值为:  num[i+1]或者*(num+i+1)
       c. int *ptr_num = num <==>int* ptr_num = &num[0]
       d. 指针变量可以指向数组元素: int* ptr_num = &num[4]; <==>int* ptr_num = num+4
   数组可以作为形参进行，实参进行传值  。比如 void a(int[] ){//函数体}   a（数组名）；进行调用 


28.指针++，是指指针的平移，平移单位是数据的类型，比如int型变量，那么一次平移4个内存单位......
29.动态分配内存————使用new分配内存：
   指针真正的用武之地：在运行阶段分配未命名的内存以存储值，在此情况下，只能通过指针来访问内存！
   运行阶段对应编译阶段，比如int num;程序直接分配一个4字节的空间供其使用，不管用不用，反正内存腾出来了。程序结束清空
   运行阶段是用new  比如：int* ptr_num = new int;//在运行阶段为一个Int值分配未命名的内存。即在运行到这句时，才在堆区分配内存
   将内存地址给 ptr_num。 ptr_num指向了新的内存空间。 delete ptr_num;//释放由new分配的内存，new和delete必须成对使用。
   int* ptr_num = new int[5];  delete [] ptr_num;//释放
   注意问题： int* p = new int; p++;因 p (所有的定义都)在栈区定义(比如int num,double i等num和i都在栈区),而new在堆区开辟了int型
   的内存给p，p此时指向这个新空间，如果p++，（因为是int型，所以一次加四个字节空间），正好空过了刚刚定义的新空间，这就是野指针或者是内存泄漏。
   int* ptr_num = new int[5];cout<< sizeof(ptr_num) << '\n';结果为 4；//new运算符  返回第一个元素的地址
   int* p = new int(10);//开辟了一个空间，并且默认值为10
   new delete成对使用，但不非要在同一个函数体内，记得释放就行
   /*-----------------------------------------内存四区----------------------------------------------------------*/
30. A .栈区（stack）:
   由编译器自动分配释放，一般存放函数的参数值，局部变量的值等。先进后出
    B. 堆区（heap）：
   一般由程序员分配释放，若程序员不释放，结束后可能由操作系统回收
    C. 全局区（静态区：static）
    全局变量和静态变量以及常量是存储到一起的，程序结束后由系统释放
    D. 文字常量区
    常量，字符串就放在这里，程序结束后由系统释放
    E. 程序代码区
    存放程序的二进制代码
    /*******************************************/
    栈区 容量小，存储速度快;堆区容量大，允许程序在允许时动态的分配内存，速度慢
    程序运行前：
     在程序编译后，生成exe可执行程序，未执行该程序前分为两个区域。
     代码区：
       存放CPU执行的机器指令
       代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
       代码区是只读的，防止程序意外的修改他的指令
     全局区：
        全局变量和静态变量存储在此
        全局区还包含了常量区，字符串常量和其他常量
        该区域的数据在程序结束后由操作系统释放
    程序运行后：
      栈区：
       由编译器自动分配释放，一般存放函数的参数值，局部变量的值等。先进后出————注意返回局部变量的地址同不能返回局部的引用一样的道理
      堆区：
       一般由程序员分配释放，若程序员不释放，结束后可能由操作系统回收
       使用new开辟
   /*--------------------------------------------------------------------------------------------------------*/
31.二维数组与指针： ==>>>>>    http://c.biancheng.net/view/2022.html   //网址介绍很详细
   首地址为 &a[0][0]或a
  a.定义一个二维数组 num[3][2]  ==>  三个一维数组，每个数组中含有2个元素；这三个一维数组的名字分别是num[0],num[1],num[2]，
  b.因为数组名就是首地址，即num[0](数组名) == &num[0][0],num[1](数组名) == &num[1][0],num[2](数组名) == &num[2][0]。
  c.第二行第二个元素的地址是:: num[1]+1   //因为num[1]理解为一维的首地址，
  d.又因为在一维数组中 num[i] 代表值 <==> *(num +i)
  e.所以由c.得 num[1] <==> *(num+1),所以c.第二行第二个元素的地址又是：：*(num+1)+1 <==> num[1]+1
  f.所以第二行第二个元素的值为：： *（*(num+1)+1） <==>*((num[1])+1)
  总：为什么使用：int(*p1)[5] = new int[3][5];  //定义一个二维数组,降维操作  ==>这是什么意思？
     new int[3][5];是定义一个二维数组的动态内存空间，将首地址返回回去；
     int(*p1)[5]  ==>  首先[]的优先级高于(), 所以可以理解为 int[4] (*p),其中int[4]是数组的类型，(*p)降维操作的意思是 想象成一维数组，*p说明p是一个指针，指向的是地址，就是=右半部分的。
     因为在一维数组中比如int a[2];int* p = a;p++,是加一个数组类型；所以在二维数组中 p+1是加 4x4=16个内存单元，因为int[4]是数组的类型。
     所以降维操作的思想就是等同于若干一维数组，利用p++去寻找每一行。
32. array就是普通数组（#include <array>），用法 array<数据类型，元素个数>,比如array<int,5> num <==>int num[5];效率高，仅C++11
    版本以后才支持这个用法。也是动态分配内存。
    和vector的区别在于，array就是普通数组的用法，比如array<int,5> num ；num[0]=1...等等，
    而vector,需要使用方法
33.输入法，中文状态下输入 v1 ，就可得到图案
34.  程序经验1——————————————————————————————————--- 实现随机数的增加，我的太麻烦了，学习学习一下大佬的手法：  
                               value_constell_state[0] += (Ptr_Temp2[1] = rand() % 11); //随机数[0,10]
                                value_constell_state[2] += (Ptr_Temp2[2] = rand() % 11); 
                                value_daughter_Money    -= (Ptr_Temp2[3] = rand() % 51);
                                 那么Ptr_Temp2[i]就是增加的值
35.
  **函数分类：
  A. 内置函数（STL和Boost C++）
  B. 自定义函数
  函数的三要素：返回值类型，函数名，参数列表
              return_type functionName(parameterList)
              {
                  //函数体
              }
  注意：函数原型中的参数名称可以省略，只写参数类型；C++中返回值不可以是数组，但可以是其他任何类型（可以将数组作为结构或者对象组成部分 返回   ）  
  ***函数指针  ：    http://c.biancheng.net/view/228.html
   A.  函数也有地址，函数名就是地址，函数的地址是存储其机器语言代码的内存开始地址,
   B.  可以在不同的时间使用不同的函数————函数可以当参数G:\C++ProgameSpace\TwelvePractise7_Demo项目
   C.  函数指针的定义方法 ：
        type (*函数名)(类型1，类型2);比如 int (*Ptr_function)(int num1,int num2);
        注意：
          该语句声明了一个指针 Ptr_function，指向一个函数
          int *Ptr_function(int num1,int num2);不是函数指针 <==>int* Ptr_function(int num1,int num2);声明了一个函数，
          返回值类型是 int*，所以()不能省略
   D.  double (*Ptrpower)(double, double) = power;就是定义一个指针函数，指向的是一个函数的地址（函数名就是地址），等同于
       double (*Ptrpower)(double, double) ;//先定义一个函数指针;Ptrpower = power;
       那么(*Ptrpower)就是调用power这个函数，和指针一个意思<==> *名就是取该地址的值
   E. C++11中引入了 auto，自动识别函数指针的类型，用法就是auto Ptrpower = power;会根据power的形式就行改变Ptrpower
   F. typedef  double (*Ptrpower)(double, double); 中Ptrpower不再是一个函数指针，而是一个类型，用法：
      Ptrpower Ptr1;此时Ptr1是一个函数指针，用它指向函数名
36. 经验：
    a. return;//退出返回值为void函数 
    b. 数组作为形参传递时，顺便传上数组的长度
    c. 源文件打开的问题：——在属性==>配置属性==>C/C++==>常规==>附加包含目录==>找到你新建.c/.cpp文件目录
       https://blog.csdn.net/LKR0325/article/details/80144149?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task
    d. extern的使用：
       在主源文件中（main.cpp）中定义了一个int* Ptr_Date_Temp = new int[5];那么在需要的源文件（如果需要）中重定义一下：
       extern int* Ptr_Date_Temp ；即可。
    e. void Function_Arrary(vector<int> Arrary)；vector<int> Arrary也就是说数组也可以作为形参进行传递,比如函数(int jj[])
       aa.数组作为函数实参时，只传递数组的地址（首地址），并不传递整个数组空间
       bb.当用数组名作为实参调用时，数组首地址指针就被传递到函数中
          void show(int value[],int len){//函数体}      int arrary[5] = {1,2,3,4,5};     show(arrary,5);
          show(arrary,5);是将arrary的首地址穿进去，相当于指针的操作，如果在void show(int value[],int len){//函数体}  
          操作会改变数组的值，如果用户不想改变原数组的元素，只是一些操作或者打印操作，那么就使用const关键字
          就是void show(const int value[],int len){//函数体} <==>保护元素的方法
       cc.
       ee.
    f.在switch  case如果想定义变量则用{}套起来，否则会有莫名错误
    g. 如果想传入函数的值，不想被改变，一定在参数列表中加入const关键字
    h. @param  是参数的意思
    i. 使用算法寻找数组中的元素：
       vector<数组类型>::iterator 对象名 = find(数组名.begin(),数组名.end(),待找元素);
       if(对象名 == 数组名.end()){//表示没有找到，}else{找到}

37. 内联函数、参数的引用传递(重点)、默认参数、函数重载(重点)、函数模板(难点)

38. 内联(inline)函数：————核心：编译器使用函数代码替换函数调用
    是C++为了提高程序运行的速度所做的一项改进(C没有)，与常规函数的区别不在于编写方式，而在于被调用时的运行机制。
   a. 常规函数的定义：int main()  |    void fun1()      |     void fun2()  |  常规函数执行时，因为函数指针学过
                    {             |    {                |     {            |
                       fun1();    |     cout<<1;        |      cout<<3;    |
                       fun2();    |      cout<<2;       |       cout<<4;   |
                    }             |    }                |     }            |
    函数在堆区都有地址（二进制形式），所以函数执行main函数是，找到fun1()所在的地址，然后去地址里面执行fun1 对应的函数体。cout<<1;cout<<2; ==>执行完fun1函数后，再用相同找地址的方式执行fun2函数。
   b. 内联函数的定义：int main()    |  inline void fun1() | inline void fun2()| 
                    {             |    {                |     {             |
                       fun1();    |     cout<<1;        |      cout<<3;     |
                       fun2();    |      cout<<2;       |       cout<<4;    |
                    }             |    }                |     }             |
    与常规函数不同在于，内联函数不是通过找地址的方式去执行，而是编译器直接将函数的函数体传到了调用的位置，这样省去了通过地址找函数体的中间过程，就是以fun1()为例：
        int main()    |  inline void fun1() |          |    int main()
         {            |    {                |    <==>  |    { 
          fun1();     |     cout<<1;        |    <==>  |       cout<<1;//内部等同于这样，就是内容传过来了
         }            |    }                |    <==>  |    } 
    使用注意(内联特性)：
    A. 二者取一： 在函数声明前加关键字inline或在函数定义前加关键字inline
    B. 多cpp源文件经验：在.cpp文件中使用正常的函数定义，在.h文件中加上关键字inline
    C. 并不是所有的函数都加inline，因为如果函数体很多的话，不建议使用这个方法，故当代码内容很少时，使用
    D.  https://blog.csdn.net/qq_33757398/article/details/81390151
38.引用（reference）———— 进阶版————为对象起了另外一个名字，引用就是别名
   在参数中，可以直接传递某个对象，而不是只是把对象复制一份（副本）。
  *** 函数返回 引用类型：——————type* 函数名(参数列表){//return 引用类型}
     a. 区分：
       double function(double num1){return double类型}虽然在函数体中定义一个局部变量{double i = 10;return i;}
       但返回后相当于 10 = double function(double num1){return double类型}；此时double result = double function(double num1){return double类型}； <==> double result = 10（返回值）
       而对于返回引用类型的变量来说，函数体中待返回的值一定要是全局变量，因为引用类型不是一个数值，而是一个名字，如果是局部变量，受限于生存空间的影响，结果就会出错。
       总结————不要返回局部变量的引用
     b.函数可以不返回值，此时默认返回传入的引用对象本身（VS编译器不支持这现象）
   引用的真谛：
      单纯给变量起一个别名 是毫无意义的，在函数参数传递的过程中，如果不使用指针或引用，传参的时候就相当于传了一个副本过来，操作
      不会改变原始值，对于数据很大时，传入副本影响效率，所以用引用进行传参时，保证不产生副本，副本占空间，此时传递就有效率。
      a.函数中不需要修改传递的参数：
        aa.如果数据对象较小，建议按值传递
        bb.传递数组只能使用指针，不能是引用，使用const关键字
        cc.多使用const关键字
        dd.较大对象则使用const +指针或引用，提高程序效率
      b.函数中需要修改传递的参数：
        aa. 数据对象是基本类型或结构时，可以使用指针或引用（基本类型建议指针）
        bb. 数据对象是数组时，只能使用指针
        cc. 数据对象是类对象时，要求使用引用
      c.
      d.
      e.
39. cin,cin.getline(),getline();用法——————https://blog.csdn.net/qq_40725780/article/details/81032700
    getline()——————只能输入字符串，用法 string a;  getline(cin,a);
    (string类型)字符串中可以使用 +  进行拼接

40.默认参数：
   void function(int num){//函数体}  在主函数中可以function（12）传12进入函数。
   使用默认参数是 在函数声明 原型：void function(int num) 中 void function(int = 10);此时 10就是默认参数
   在函数调用时可以 function(); //此时默认传入是10;  function(12);//当然也可以不要默认值
   注意：
     a. 默认值可以在函数定义或声明(原型)中给出，不能两个位置同时出现
     b. 对于带参数列表的函数，参数列表必须从右向左进行添加默认初值
       ( √ )void test1(int a ,int b = 1,int c =5);  ==>此时test1(1);传值是从左向右，此时a传入1;test1(1,2);此时a= 1,b =2,c默认
       ( × )void test1(int a ,int b = 1,int c );    ==>必须从右向左添加传值，c没有，不可能有b
       ( √ )void test1(int a=2,int b = 1,int c =5); ==>test1();全部使用默认值;test1(1);a=1,b,c默认;test1(1,2);此时a= 1,b    =2,c默认;test1(1,2,3);全不使用默认值，a = 1,b=2,c=3;
41. 函数重载(overloading)————https://blog.csdn.net/alidada_blog/article/details/80734900
    指可以有多个同名的函数;函数名相同，参数列表不同(特征标不同)
    编译器在编译时，会根据参数列表的不同自动的对函数进行重命名————专业术语：重载决议，举例：
     void swap(int a,int b){};          (经过重载决议)  swap_int_int
     void swap(double a,double b){};    ==> ==> ==> ==> swap_double_double
     void swap(int& a,int& b){};                        swap_int_int
     所以 参数列表是引用的话，会报错，因为引用参数实际和普通同型是一样的，G:\C++ProgameSpace\FourteenPractise1_Demo案例
     总结——
    a. 从编译器角度看,函数名(type)和函数名(type& )特征标是相同的(特征标就是参数列表的意思)，编译器将类型引用和类型本身视为
     同一个特征标
    b. 不区分const和非const变量
    c. 结合以上两点，在重载中引用和const是不起作用的
    重载的规则：
    a.函数名称必须相同
    b.参数列表必须不同
    c.函数的返回类型可以不同也可以相同
    d.仅仅返回类型不同，不是重载
42.函数模板(Function Template)————
  所谓函数模板，实际上就是建立一个通用函数
    a.函数定义时不指定具体的数据类型(使用虚拟类型代替)
    b.函数被调用时编译器根据实参反推数据类型——类型的参数化
  使用方法：
    a. 定义函数时：
    template<typename T>
    返回值类型（返回值类型也可以为虚拟类型） 函数名(参数列表){//函数体中可以使用虚拟类型}
    b. 声明函数时：
    template<typename T>返回值类型 函数名(参数列表);
    //可以将<typename T> 写成<class T>  二者等价

    案例：G:\C++ProgameSpace\FourteenPractise3_Demo
    用函数模板 简化 函数重载 效果很好哟！！！案例：G:\C++ProgameSpace\FourteenPractise3_Demo
    函数模板替换重载的前提是：重载函数实现的功能一样，只不过传入的数据类型不同;但重载可能实现的功能不同时，不可用模板替换
/*-------------------------------------------------------------------------------------------------------------*/
                                       黑马程序员————模板部分
1.C++另外一种编程思想是泛型编程，主要利用的技术就是模板。
  语法：
        template+ <模板参数列表（不唯一）> + 函数模板或类模板 
 *C++提供两种模板机制：  函数模板和类模板 
2.函数模板：template<typename T>
   判断虚拟类型T的方法：
  *自动类型推导————函数被调用时编译器根据实参反推数据类型——类型的参数化
  *显示指定类型———— 函数名<类型>(参数)
  注意：模板必须确定出T的类型才可以使用（如果函数体中没有用到T，那么确定的方法，最好是显示指定类型）
3.普通函数与函数模板的调用规则：
 * 如果函数模板和普通函数都可以实现，优先调用普通函数
 * 可以通过空模板参数列表来强制调用函数模板 ；函数名<为空>(参数);
 * 函数模板也可以发生重载
 * 如果函数模板可以产生更好的匹配，优先调用函数模板
4.模板函数的局限性：
  *比如在模板函数中提供判断if(a == b)等等一系列关系运算符，（ab为T虚拟类型）。如果此时传入的是类类型或者数组
  那么就会报错，解决的方法可以使用运算符重载。也可以提供模板的重载，为这些待定的类型提供具体化的模板。
  *总结：模板不是万能的，有些特定的类型需要用具体化的方式做特殊实现，具体化的重载模板 会优先调用，比如：
   template<> void func(Person& a1, Person& a2){};  //用Person类实例化了 typename T
  G:\C++Program\黑马程序C++\35
5.类模板：
  *建立一个通用的类，类中的成员 数据类型可以不具体指定，用一个虚拟的类型来指定
  *语法：  template<typename T> 类；//和模板函数几乎一样G:\C++Program\黑马程序C++\36
  因为在类中数据类型可能不唯一，所以要初始化类参数列表中的数据，比如template<class Typename,class Typeage....>
  (class==Typename最好在函数模板中用后者，类模板用前者)，在调用的时候，只能使用显示指定类型。如：Person<string, int> p1
6.函数模板 和 类模板的区别：
 * 类模板只能使用显示指定类型
 * 类模板在模板参数列表中可以有默认参数
   比如： template<class Typename,class Typeage = int>+ 类；
          调用时：  Person<string> p2("君君", 24);
7.类模板中的成员函数和普通类中的成员函数创建时机是有区别的：
  * 普通类中的成员函数一开始就可以创建
  * 类模板中的成员函数在调用时才创建
8.类模板对象做函数参数
  *类模板实例化出的对象，向函数传参的方式
  一共有三种方式：（第一种最常用）
  *指定传入的类型——————直接显示对象的数据类型

  *参数模板化  —————将对象中的参数转变为模板进行传递

  *整个类模板化—————— 将这个对象类型 模板化进行传递
9.类模板和继承 
  *当子类继承的父类是一个类模板时，子类在声明的时候，需要指出父类中T的类型，
   class Son :public Base<int>{};（即初始化模板参数列表）
  *如果不指定，编译器无法为子类分配内存
  *如果想灵活指出父类中T的类型，子类也需要为类模板
   template<class T1,class T2> //template<class T1,class T2......>
   class Son2 :public Base<T1>{}；//<T几都可以，根据要求>
10.类模板成员函数的类外实现
   //1. 要有作用域，即该成员函数属于哪个类   Base::
   //2. 因为Base是一个模板类，所以作用域的前缀，要体现出模板 Base<T1,T2>
   //3. 编译器还是不清楚参数列表中T1,T2的意思，以此要加上模板声明  template<class T1,class T2>
   比如： template<class T1, class T2>
          Base<T1, T2>::Base(T1 name, T2 age){}  //类外实现定义
11.类模板的分文件实现
  //解决方法：
  //  1. 将模板类的头文件中的.h改成 .cpp(main所在的头文件中更改即可，子头文件中无需更改)
  //剖析1:类模板的成员函数只有在调用的时候，才开始创建。当头文件下只有.h时，编译器只看到了.h中的类声明，而不知道类定义
  //因此在调用 b1("junjun",24);和b1.show();时会出错。将.h 更改为.cpp，编译器会看到.cpp中的成员定义以及类的声明
  //  2.(常用的方法)将模板类的声明和类的定义，放在同一个文件下，将文件后缀名改为.hpp , .cpp就不需要了
12.类模板与友元
  //1. 全局函数 类内实现  ————直接在类内声明友元即可
  //2. 全局函数 类外实现  ————需要提前编译器知道全局函数的存在
/*-------------------------------------------------------------------------------------------------------------*/
43. 面向对象编程(难点)，类和对象，类的成员变量，访问修饰符，构造与析构函数(重点)，this指针(重点)
    函数  == 方法 

44.何为面向对象？-————
    所谓面向对象就是基于对象概念，以对象为中心，以类和继承为构造机制，来认识，理解，刻画客观世界和设计，构建相应的软件系统(模拟现实)。
      a.对象是由数据和容许的操作组成的封装体，与客观实体有直接对应关系 <==>对象是属性和方法的集合
      b.面向对象不是某一种语言特性，而是一种编程思想
    相对于面向对象，是面向过程(结构)，定义不同的函数去细化实现所想实现的功能(就是平常写的代码),想实现的功能都是死的
    (个人初总结：面向对象是编程思想，是以对象为中心，由类和继承去构造，类就是将拥有共同属性的这么一类对象封装起来，封装内容就是属性)
45. 抽象————
       从具体事物抽取共同的本质特征。==>(处理抽象的方法是简化)
    类——————(是一个概念)(类中内容可以称为属性)
       是一种将  抽象  转换为  用户定义类型  的工具。
       将数据表示和操纵数据的方法组合成一个整体
       类的实例称为对象   ==>  对象是类的实体，对象的集合就是类
       类中的变量和函数称为成员
    类的声明：
       使用class/struct关键字声明
          class 类名(){};    struct 类名(){};
          注意：
          1.class 方式声明的类型与struct声明的的类型仅仅是形式上不同，
          2.其唯一区别在于使用class声明的类型默认成员是私有的(private)，而struct声明的类型默认是共有的(public);一般使用class，
          而在描述结构时，用struct，里面全装数据

46.访问修饰符：
   public ：修饰的成员在任意地方都可以访问
   private: 修饰的成员只能够在类的内部或者友元函数中访问——(目的是保护数据)，（数据可以被初始化）
   protect: 修饰的成员可以在类中函数、子函数以及友元函数中访问
47. 构造函数： 
   特点：
      以类名作为函数名；
      无返回值类型;   return;直接返回
   作用：
      初始化对象的数据成员
      类对象被创建时，编译器为对象分配内存空间并自动调用构造函数以完成成员的初始化，前句的意思是，当创建一个空对象
      时，所占空间就为1个字节，这样做的目的是为了区分空对象占内存的位置
    构造函数的种类;
      无参构造(又称为 默认构造 )
      一般构造(重载构造) 
             一个参数的构造又称为 转换构造<==> <==>类 对象(参数)或者类 对象 = 参数
      拷贝构造
48.    经验：
       a.如果成员函数代码很少，可以直接在类中定义。只要在类中定义的函数，不管加不加inline关键字，都默认为内联函数
       b.私有的成员变量建议加个_,比如 _name;
       c.使用  内联方法(函数)  实现对 成员变量(private区) 的封装 Get/Set方法
       d.在类中的方法声明：返回值type 函数名(参数列表);//除了内联函数外
         在.cpp文件中定义：返回值type 类名::函数名(参数列表){//函数体}
                                          ::称为作用域简析运算符，代表从属关系
       e. 构造函数的重载规则与普通函数的重载相同
       f. 如果构造函数中，只有一个参数比如：DemoV5::DemoV5(int age){} 那么在主函数中可以DemoV5 对象名  = 18;直接赋值
       g. 用构造函数给成员初始化时，比如DemoV5::DemoV5(string name, string desc){_name = name;_desc = desc} 可以简化为
           DemoV5::DemoV5(string name, string desc):_name(name),_desc(desc){//其他函数体}
       h. 除了使用 类名 对象名;(或者类名 对象名(构造传参);)的方法使用类,还可以 类名* 对象名 = new 类名;//用类名定义了一个指针
          变量，同时为其在堆区开辟了内存空间，或者类名* 对象名 = new 类名(构造传参);
          那么在调用类中的成员时，用 对象名->成员 
          第二种方法推荐

49.析构函数：
   对象过期时   自动的调用    的特殊成员函数，一般用于来完成清理工作，析构函数的名称是在类名前加~，析构函数没有参数，只能有一个
   用法是，如果存在变量在类中使用new在堆区开辟了空间，那么就在析构函数中delete 释放资源;如果是用类定义一个变量，比如：
   DemoV5* stu3 = new DemoV5("小撒","北大也可以"); 在main下面一定用delete释放
   注意：
     析构函数用来释放对象使用的资源，并销毁对象的非static数据成员
     无论何时一个对象被销毁，都会自动调整其析构函数(隐式析构)
50.使用类创建对象
   a.第一种实例化方式：
      栈内存中创建：类似声明变量
      自定义类型名 对象名;(或者自定义类型名 对象名(参数列表);)
      注意：对象由系统创建并释放，不用担心会出现内存泄漏;对象的声明周期仅在声明区域的大括号内;栈内存的优势是存取速度快(仅次于寄存器)，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性
   b.第二种实例化方式：
      在堆内存中创建，需要new关键字，比如类名* 对象名 = new 类名;或者类名* 对象名 = new 类名();
      通过 对象名 -> 成员;或者  *对象名.成员
      注意：
       此时对象是指针，必须用delete进行释放内存;
       使用灵活(可以赋值给全局变量，可以把对象作为函数的返回值返回)
51.this指针
      ——（可以理解为“当前的”或“这个”的对象）
   每个成员函数（包括构造和析构函数）都有一个this指针，在析构以后就清除
   this指针指向调用对象时，既可以通过this关键字访问当前对象的成员;比如： 
     a. 访问成员变量 this->成员名
     b. 访问成员方法 this->函数名();
   注意：
     a. this指针的类型为类 类型*const（类名* const），为有值
     b. this指针本身不占用大小，他并不是对象的一部分，因此不会影响sizeof的结果
     c. this的作用域在类成员函数内部
     d. this指针是类成员函数的第一个默认隐含参数，编译器自动维护传递，类编写者不能显示传递
     e. 只有在类的非静态成员(static)函数中才可以使用this指针，换言之，只有static函数中不可以使用this
   this返回当前对象的引用
     *this 表示当前对象
    函数的结尾加const，表示函数内部不允许修改对象本身，调用本对象非const方法就会报错
52.大佬精彩代码：G:\C++ProgameSpace\SixteenPractise6_Demo
    A.  this->m_scores[this->scorecount-1] = score;  //将新输入的数据存到数组
        /**由于不可能只有一科，但m_scores数组已经定义只有一个堆区空间，所以必须定义一个新的堆区内存*/
        float* Ptrscores = new float[scorecount+1];
        float* Oldscores = m_scores;
        memcpy(Ptrscores, m_scores,sizeof(float)*(scorecount));//在头文件<string>中
        scorecount++;
        m_scores = Ptrscores;    //m_scores指向了新的堆区空间内存
        delete Oldscores;
     //代码解释： 在项目开发中，先在堆区定义一个小的内存，然后用用一个随动的空间float* Ptrscores = new float[scorecount+1];去
    存储，然后用本来的小数组去指向这个随动区域，但是一定要将原来的内存，释放掉float* Oldscores = m_scores;delete Oldscores;
       就是定义一个新的指针去指向你原来的内存，最后释放
    B. //判断当前数组容量是否已经满了
       if (this->m_length == this->m_capacity)
       { 
         //如果满了，就扩容，当前容量*2+1
         T* newelements = new T[this->m_capacity*2 +1];
         memcpy(newelements, m_elements,sizeof(T)*this->m_length);
         delete[] this->m_elements;
         m_elements = newelements;   //指向新空间
       }
         this->m_elements[this->m_length] = element;
         this->m_length++;

53. 运算符重载 ，友元函数 ，一元运算符重载，重载<<运算符，类的自动转换和强制转换

54.运算符重载（Operator Overloading）
   ————就是想法转换，他的目标是简化函数调用的方式;针对对象使用
     a. 把标准的函数使用方法，重新定义为自己认为的方式，仍然支持本身的用法，比如+重载为支持对象之间的操作，但是仍保留+本身数+数
     b. 所谓重载就是赋予新的含义
     c. 运算符重载也是一个道理，同一运算符可以有不同的功能
     D.运算符重载支持 重载函数（多个），比如运算符+：可以operator+(Integer other) 只有一个类对象，也可以
        operator+(Integer other,int num);一个类和一个整型数据相加...等等一系列

   定义一个运算符重载就像定义一个函，只不过这个函数名称以operator关键字开头 
   运算符重载的语法格式：
     返回类型 operator被重载的符号 (参数列表)
    举例： 
     Integer Integer::operator+(Integer other)   //operator+ 重载后+的对象是（参数列表的类型）
     {
        Integer result(this->m_value + other.m_value);   //用于返回加法的结果，result是局部变量
        return result;
    }
     /**  返回类型是对象 
       *  重载+号。+本身不能用于对象之间的加，但重载后可以
       *   Integer int1(1024), int2(2068), int3;   //声明3个对象
            int3 = int1 + int2;
       *  重载加号以后，以后碰到对象之间的加后，就把+号等同于函数  就是+   <==> .operator+(参数列表)
          //定义一个运算符重载就像定义一个函数
       *  所以int3 = int1.operator+(int2)
     **/
     注意：
      a. 重载不能修改运算变量的个数，比如关系运算符是二元的，重载后也必须是二元的
      b. 重载不能修改运算符的优先级
      c. 重载不能修改运算顺序
    可以被重载的运算符包括所有C的运算符，如下：
         二元运算符： + - * / %
         关系运算符： ==   !=  <  >  <=  >=
         逻辑运算符： ||  &&  !
         一元运算符： +(正号),-(负号),*(指针),&(取地址),++,-- （++ -- ==>> G:\C++Program\黑马程序C++\22）
         位运算符：  |  &  ~ ^  <<    >>
         赋值运算符：= += -=  *=  /=  %=  &=   |=  ^=  <<=   >>=
         内存声明与释放： new,  delete ,new[],delete[]
         其他运算符： ()(函数调用运算符，重载后特别像函数的调用，因此也称为仿函数)   -> (成员访问)    ->*(成员指针访问),   ,(逗号) ,[](下标)
    不能重载的运算符有5个：
        .(点运算符),  *(成员指针访问运算符),  ::(域运算符),   sizeof(长度运算符),  ? : (三元运算符)
55.const
   const  修饰指针变量时 ：
     a. 只有一个const时，如果const位于*左侧，（const type* 名  <==> type const * 名 ），此时指针所指的数据为常量，不能通过指针
        修改实际数据，因地址不是常量，可以利用地址指向别的内存，进而改变指针值。
     b. 只有一个const时，如果const位于*右侧，（type * const 名），此时指针本身是常量，不能指向别的内存单元，但所指的数据可变
     c. 如果有两个const分别在*的两侧，表示指针和所指向的数据都不能修改
   const  修饰参数时 ：
     a. void test(const int num){} //表示传递进来的参数不可改变
     b. const修饰对象时 函数名(const 类& 对象){}//将传入的对象中的成员变量和方法置为常量都不能修改，如果要调用方法，那么调用的
     方法也一定是const类型(在函数体中const成员函数，不能调用非const成员函数),在欲调用函数定义后面加const即可
     c. 使用const 修饰返回引用类型的一个原因是：提高效率==就是const在函数定义的开头 ——————————表示返回常量， 只读
     d. 函数定义的结尾加const，表示函数内部不允许修改当前的（成员）变量和方法本身，调用本对象非const方法就会报错，与b相同

56. 证同测试
     if(this == &传入的对象名)return *this;//返回当前对象
     打印地址
      printf("%p", str.m_value);    //打印地址 
     数组空值操作：
    if (this->m_datas == 0)
      this->m_datas = NULL;        //如果数组长度为0，那么数组为空值
    错误打印：
      cerr<<""<<endl;
    返回副本  无法赋值，只能为左值，所以有时必须返回引用，可以为右值；

57.友元函数：
   在运算符重载中 如果+被重载为 两个对象的加法(G:\C++ProgameSpace\SixteenPractise2_Demo\main)，比如定义对象，类 对象1，对象2;
   那么对象1+对象2是正确的，但是把某个对象变为常量，就错了，比如  数+对象
   解决方案是————友元函数(关键字 friend)
     友元函数在定义时，不需要::(域运算符)，
     在声明时加friend,在定义时，不写 
     在友元函数声明，定义时，不能加const后缀
  使用场合：
    a.C++规定，赋值运算符=，数组下标运算符[]，函数调用运算符（），成员访问运算符->, 这些在重载时必须声明为类的成员函数
    b.流运算符<<,>>，类型转换运算符不能定义为类的成员函数，只能是友元函数
    c.一元运算符和复合赋值运算符重载时，一般声明类的成员函数
    d.二元运算符在运算符重载时，一般声明为友元函数
    e.成员函数和友元函数二选一

58.复制构造函数（拷贝构造）
   类 对象1，对象2;
   如果令对象1 = 对象2;
   注意： 如果我们不重载赋值运算符(=)，对象2 的内容直接复制到对象1中，对于没有指针的简单类来说就足够了，但当类中含有指针成员时
   ，逐字节的复制将会把指针从一个对象直接赋给另一个对象，而这两个指针就会指向同一个内存。
   以上文字的叙述其实就是浅拷贝，在创建一个对象后，会自动的创建三个方法，构造方法，析构方法和拷贝构造方法；
   此时的拷贝构造方法就是进行简单的对象间属性（成员变量）的赋值，担当用户自己定义拷贝构造后，此默认拷贝会销毁。
  浅拷贝的问题———— G:\C++Program\黑马程序C++\14



   解决方案就是
    a. 重载赋值运算符 -————结果将是：对象1 = 对象2;后两对象值相同，但地址不同
       /** 成员函数方式 重载 =运算符，实现字符串的复制*/
       const String & String::operator=(const String & str)
       {
          if (this == &str)return *this;    //证同测试,判断是不是自我赋值
          delete[]  this->m_value;          //把以前的空间释放掉
          this->m_length = strlen(str.m_value);
          this->m_value = new char[this->m_length+1];   //深拷贝 
          strcpy(m_value,str.m_value);
           return *this;
      }
      注意：
        当重载赋值=运算符时，务必将一个对象中所有数据成员都复制到另一个对象
        如果包含多个数据成员，则每个成员都需要复制到目标对象中

    b.拷贝(复制)构造函数————就是以对象为参数的构造函数（参数中必须有const和引用），
                                                                  和=差不多，一定把所有属性（成员变量）都进行赋值
    String::String(const String & str)
    {
      this->m_length = strlen(str.m_value);
      this->m_value = new char[this->m_length+1];        //深拷贝 
      strcpy(m_value,str.m_value);
    }
   在下面三种场景中会调用复制构造函数  G:\C++Program\黑马程序C++\13
     a. 当类的对象被初始化为同一类的另一个对象时 
     b. 当对象被作为参数传递给一个函数
     c. 当函数返回一个对象
/****************************************************************************************************************/
 深拷贝和浅拷贝：
   浅拷贝： 简单的赋值拷贝操作；
   深拷贝：在堆区重新申请空间，进行拷贝操作
/****************************************************************************************************************/
59.类型转换
   A.自动类型转换比如：   int a  = 12； a= 22.5+a;
   B.强制转换    比如：   int num = int（99.5）/ (int)99.5，后者是C语言的风格
   C.当前类型转换为其他类型————实现方法：类型转换函数
     注意类型转换函数，只能以成员函数的形式出现，也就是只能出现在类中
     特点：
       a.类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型
       b.类型转换函数也没有参数，因为要将当前的类的对象转换为其他类型
    /** 实现的功能是将当前类型转换为其他类型
      * 类型转换函数的语法格式
        operator type()
        {
          return data;
        }**/
      注意：
       a. type可以是内置类型，类类型以及由typedef定义出来的类型别名，任何作为函数返回类型的类型（void除外），都是被支持的
          （不允许转换为数组或函数类型，可以转换为指针或引用类型）
       b. 类型转换函数一般不会更改被转换的对象，所以通常加const
       c.类型转换函数可以被继承，可以是虚函数

60. C++三个重要特性：：：：：封装(就是将成员变量属性，方法等封装在一个类中，用于描述世界上的事物)   
                             继承   
                             多态

61.继承（inheritance）和派生  ————————概念
   原有类（基类）————又称为父类，派生类又称子类
   特点：
   a. 就是在一个已经存在的类基础上，再建一个新类
   b.从已有的类派生出新的类，派生类就继承了原有类（基类）————又称为父类，的特性，包括成员和方法
   通过继承可以完成下面的一些功能
   a.可以在已有类的基础上添加新的功能，如对于数组类，可以添加数学计算
   b.可以给类添加数据成员，如对于字符串类，可以派生出一个类，并指定成员表示颜色
   c.可以修改类方法的行为，如对于普通英雄类，可以派生出拥有更丰富技能的英雄
   注意：
   a.继承机制只需提供新特性，甚至不需要源码就可以派生出类，就是，如果购买的类库只提供了类的方法的头文件和编译后的代码，仍可以使用库中的类派生出新的类，而且可以在不公开实现的情况下将自己的类分给他人，同时允许他们在类中添加新特性
   使用继承的优点：
   a. 基类定义公共内容，方便统一修改
   b. 可以重定义基类的成员函数
   c. 添加新类、新成员方便
   注意：
   a. 派生类对象存储了基类的数据成员，即派生类继承了基类实现
   b. 派生类对象可以使用基类的非私有成员，即派生类继承了基类的接口
   c. 派生类需要自己的构造函数
   d. 派生类可以根据需要添加额外的数据成员和函数
   笔记：
    派生类与基类之间的特殊关系小结
    A. 派生类可以使用基类的非私有成员函数，（包含 public ,piotected）
    B. 基类指针可以在不进行显示转换的情况下指向派生类对象，那么基类对象不能指向派生类中的成员
       比如 Warrior(子类) Warrior1(子类对象);  //  a b  c相同
       a. Hero(父类) * Hero1 = new Warrior(子类);
       b. Hero(父类)& Hero1  = Warrior1;   
       c.  Hero(父类) * Hero1 = &Warrior(子类);
       Warrior(子类) & Warrior2(子类对象) = (Warrior&)Hero1;  //将父类对象强制转换为派生类对象，强转是因为父类中的内存空间仅为
       当前的成员变量，而子类的内存空间不仅有父类的成员变量还有本身的成员变量，内存空间比父类大，因此不能直接转
    C. 不可以将基类对象和地址赋给派生类引用和对象，可以将派生类对象直接赋给基类对象
    D. 基类指针或引用只能调用基类函数，不能调用派生类对象
    E. 
   //说明： 某个方法是指 子类会有和父类同名的方法
   //1.派生类中如果不实现某一个方法，那么派生类对象会默认的调用基类的实现
   //2.派生类实现了某个方法，那么派生类对象就会调用子类实现
62. 继承又分为 公有继承(public)，私有继承(private)，受保护继承 (protected)
              ——————继承包括所有的属性和方法都要继承，代码不是共享（创建对象那样）
    公有继承(public)：
     基类的公有成员和受保护成员，在派生类中保持原来的访问属性，其私有属性为基类特有，派生类访问不到
     全部继承，不封装基类，那么用公有继承
   私有继承(private)
     基类的公有成员和受保护成员，在派生类中成了私有成员，其私有属性为基类特有，派生类访问不到
     全部继承，完全封装基类，那么用私有继承
   受保护继承 (protected)
      基类的公有成员和受保护成员，在派生类中成了受保护成员，其私有属性为基类特有 ，派生类访问不到
      全部继承，有选择封装基类，那么用受保护继承
63. 笔记
    A.没有继承时，成员变量和成员方法分开存储：
      对象的内存中只包含成员变量，存储在栈区或堆区（使用new创建的对象） 
      成员方法与对象内存分开，存储在代码区
      注意：
      a.编译器会将成员变量和成员函数分开存储，分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码
      比如：  类* 对象1 = new 类; 类* 对象2 = new 类;  对象1 和对象2都共享同一段函数代码，但都为各自变量分配内存
      b.类可以看做是一种复杂的数据类型，如果使用sizeof测量类所占空间，会发现，只是计算了成员变量的大小，并没有把成员函数也包含
    B.有继承关系时
    派生类的内存大小可以看成由基类成员变量和新增成员变量的总和。
    比如 (派生)类* 对象 = new 类; 那么在堆区内其实是先包含了基类的成员变量，再包含了派生类本身的成员变量
    所有成员函数仍然存储在另外一个区域————代码区，由所有对象共享
/*-------------------------------------------------------------------------------------------------------------*/
                                          黑马程序员 继承部分
1.继承的优点就是：减少重复代码
2.语法： class 子类 ： 继承方式  父类
3.派生类的内存大小可以看成由基类成员变量和新增成员变量的总和<==>（sizeof(子类)）。从基类继承过来的表现为共性，
  而新增的成员表现为个性

4.利用开发人员命令提示工具查看对象模型————有左侧菜单中找到VS2015的开发人员命令提示符
  A. 跳转盘符：解释调到程序所在的盘符，比如我保存在G:\C++Program\黑马程序C++，那么输入 G: + 回车
  B. 跳转文件路径：  cd + 空格 + 具体路径下+回车
  C. 查看命名：  cl(英文l)+空格+/d1(数字1)+空格+reportSingleClassLayout+类名+空格+当前类名属于哪个头文件（比如
  main.cpp）（如果该文件存在，那么输入首字母后按下Tab键就可以完成）+回车
     比如G:\C++Program\黑马程序C++\25\main\main>cl /d1 reportSingleClassLayoutSheepTuo main.cpp

5.继承中构造和析构的顺序：
  当创建一个子类对象后，先构造父类再构造子类（先有父后有子），析构的顺序相反，先析构子再析构父类
6.继承同名成员处理方式：
  问题：当子类和父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？
   * 访问子类同名成员，直接访问即可（.运算符）
   * 访问父类同名成员，需要加作用域
   A.如果是成员属性（变量）：
       那么 子类 子对象；  子对象.变量；      <==> 访问的是子类的该变量
                           子对象.基类::变量；<==> 访问的是父类的该变量
   B.如果是成员方法（函数）：  
       那么 子类 子对象；  子对象.函数；      <==> 访问的是子类的该函数； 
                           子对象.基类::函数；<==> 访问的是父类的该函数
   C.如果子类和父类有同名的属性和方法，但是子类中没有定义，那么子类调用，会优先调用父类的，如果二者都存在，那么用
     以上A B的方法
  综上： 如果子类中出现和父类同名的函数，子类的会隐藏掉父类的中所有的同名函数（包含重载版本），如果想访问父类被隐藏的成员函数，需要加作用域。
7.继承中同名静态成员处理方式
  问题：继承中同名的静态成员在子类对象上如何进行访问？
  静态成员和非静态成员出现同名，处理方式一致，即
     * 访问子类同名成员，直接访问即可（.运算符）
     * 访问父类同名成员，需要加作用域
8.多继承语法 ——————C++允许一个子类有多个基类
 语法： class 子类::访问方式 父类1，访问方式 父类2........{};
 多继承可能引发（不同）父类中有同名成员的出现，需要加作用域区分；
 C++实际项目中，不建议使用多继承
9.菱形继承（钻石继承）
  两个派生类继承同一个基类，又有一个类同时继承这两个派生类.
  菱形继承的问题是：子类继承了两份相同的数据，导致资源浪费以及毫无意义。
  解决方法是：利用虚继承（virtual关键字）解决，使基类变为虚基类，语法：class sheep :virtual public Animal
                            G:\C++Program\黑马程序C++\25
  //虚继承、虚基类：virtual实现的底层原理是：
  //virtual后sheep和Tuo内部不再是各有一份来自基类的相同数据，而内部各是一个vbptr（称为虚基类指针）
  //指向的是vbtable(虚基类表)，该表中记录的是一个偏移量数据，就是vbptr所对应的位置+偏移量的数据
  //所指的内容就是基类中的数据，此时只有一份。不像不加virtual前那样，各有一份。此时两个子类共指一份数据
/*-------------------------------------------------------------------------------------------------------------*/
64.类的组合形式
  在一个类中有另外一个类的对象作为数据成员，这种方式叫做类的组合形式
  继承是纵向的，组合是横向的

65. 多态性（polymorphism）与虚函数  -——————变化体现在参数上
    面向对象编程的多态性包括：
    静态的多态
    A.向不同的对象发送同一条消息（所谓消息，就是函数调用）——————不同的对象可以调用同一个函数
    B.不同的对象在接收时会产生不同的行为
      ————不同的行为，就是指不同的实现，即指向不同的函数
      ————函数名相同，但执行的具体细节不同

   动态多态性————函数重写
   A.要实现C++函数的重写，必须要先把父类的成员函数设定为虚函数
     virtual 返回值 函数名();  同时 在 子类的相应方法后加override（可不加，在子类重写函数前缀可加可不加virtual）
   B. 比如在父类中我定义一个 Move(){}方法，类名为Hero;  在子类中我也定义一个Move(){}方法;二者方法的实现不同。
    当我在另一个类中定义一个MoveRole(Hero & Other){other.Move()}方法时，当我在主函数调用MoveRole方法时，不管传入的参数是基类的
    还是子类，都会执行基类中Move()的代码。（向上转换）
     如果我在父类Move方法声明中加virtual 在子类的相应方法后加override，就代表父类的函数允许子类重写，当我在主函数调用MoveRole方
     法时，传入子类的对象，就会执行子类的函数
     G:\C++ProgameSpace\EightteenPractise1_Demo
/*-------------------------------------------------------------------------------------------------------------*/                                         黑马程序员——————多态
 virtual在声明和定义中只出现一次即可。
1.多态分为两类：
  *静态多态： 函数重载 和 运算符重载属于静态多态，复用函数名
  *动态多态： 派生类和虚函数实现运行时多态
  二者区别：
  *静态多态的函数地址早绑定————编译阶段确定函数地址
  *动态多态的函数地址晚绑定————运行阶段确定函数地址
2.在C++中允许父子之间的类型转换，父类的引用或指针都可以直接指向子类对象（不需要强制转换）。
   笔记：
    派生类与基类之间的特殊关系小结
    A. 派生类可以使用基类的非私有成员函数，（包含 public ,piotected）
    B. 基类指针可以在不进行显示转换的情况下指向派生类对象，但是基类对象不能指向派生类中的成员
       比如 Warrior(子类) Warrior1(子类对象);  //  a b  c相同
       a. Hero(父类) * Hero1 = new Warrior(子类);
       b. Hero(父类)& Hero1  = Warrior1;   
       c.  Hero(父类) * Hero1 = &Warrior(子类);
       Warrior(子类) & Warrior2(子类对象) = (Warrior&)Hero1;  //将父类对象强制转换为派生类对象，强转是因为父类中的内存空间仅为
       当前的成员变量，而子类的内存空间不仅有父类的成员变量还有本身的成员变量，内存空间比父类大，因此不能直接转
    C. 不可以将基类对象和地址赋给派生类引用和对象，可以将派生类对象直接赋给基类对象
    D. 基类指针或引用只能调用基类函数，不能调用派生类对象
3.多态满足的条件：
  （一个函数提供了多种不同的接口）
  *有继承关系
  *子类重写父类中的虚函数
     重写： 函数返回类型 ，函数名 ，参数列表 完全一致称为重写
  多态使用条件：
  *父类指针或引用指向子类对象

4.基于 3 进行 剖析——————多态动态的原理

  void speak() //父类的方法                     |   void speak() //子类的方法  ，对父类的方法进行了重写
  {                                             |   {
    cout << "Animal 父类方法的调用 ！" << endl; |      cout << "Dog 子类方法的调用 ！" << endl;
  }                                             |   }
  ------------------------------------------------------------------------------------------------------------
  
  void Do_Speak(Animal& a)   |       Dog d;         //创建一个子类对象                          
  {                          |       Do_Speak(d);   //函数调用
    a.speak();               |
  }                          |
  以上四块区域的代码，满足了多态的条件和使用条件。
  在编译时，当编译到第三块代码区时，会为这个函数分配地址，且自动转向父类方法的调用。因此当父类的指针或引用指向子类
  对象时，仍会执行父类的方法。
  更改的方法是使用动态多态，在父类方法前加virtual，子类后面加override，实现运行时分配内存，当传入子类对象后，会执行子类的方法。
  在没加virtual前，（假设基类和子类中没有属性（变量）），那么sizeof(基类)= 1；
  加virtual后，    （假设基类和子类中没有属性（变量）），那么sizeof(基类)= 4；
  后者因为加上virtual后，基类内部会有一个4个字节的指针，指针称为vfptr（虚函数指针），指向的是虚函数表vftable，
  表内部记录一个虚函数的地址（记录方式为：&父类::虚函数）
  而对于子类中，当没有实现对方法的重写时，子类继承父类的属性和方法，把父类的属性和方法都拿过来一份，所以子类内部会有和父类一样的方法，且内部有vfptr（虚函数指针），指向的是虚函数表vftable，表内部记录一个父类虚函数的地址（&父类::函数）。
  当实现对基类虚函数的重写后，子类中的原虚函数地址会替换成现子类的虚函数地址（此时的记录方式为：&子类::虚函数），即用
  子类虚函数指针指向的地址覆盖子类中 原父类虚函数指向的地址。父类中虚函数表vftable仍然为&父类::虚函数。当父类的指
  针或引用指向子类对象时，会发生多态，（即Animal& a = d(d为子类)），当a.speak(); 时，此时因为为子类的对象，所以会从子类的虚函数表中去找子类的虚函数。
5.纯虚函数和抽象类 
  virtual前缀的函数为虚函数 ，通常我们将父类中的某一个函数定义为虚函数，目的是让子类中的函数对其重写，当我们用不到
  父类中的这个虚函数时（就是父类中的仅仅是被重写，而无实际的作用时），可以将其定义为纯虚函数，即
                       virtual 返回值类型  函数名() = 0;
  当某个类中出现纯虚函数时，此类为抽象类，抽象类的特点是
  * 不能实例化对象；
  * 抽象类的子类，必须重写父类中的纯虚函数，否则也为抽象类
  比如子类中重写：    virtual 返回值类型  函数名(){//函数体}   //就是重写，和多态的一样
                G:\C++Program\黑马程序C++\28
6. 虚析构 与 纯虚析构
               G:\C++Program\黑马程序C++\28
  问题原因：多态使用时，如果子类有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码
  解决方式： 将父类中的析构函数改为虚析构或纯虚析构
  虚析构 与 纯虚析构的共性：
  *可以解决父类指针释放子类对象
  *都需要具体的函数实现
  虚析构 与 纯虚析构的区别
  *如果是纯虚析构，该类属于抽象类，无法实例化对象
  虚析构的语法：
  *定义版本： 类名::~类名(){}
  *声明版本： virtual ~类名()；
  纯虚析构的语法：
   *声明版本： virtual ~类名() = 0；
   *定义版本： 类名::~类名(){}
   //不论是虚析构还是纯虚析构，都需要有代码，以为可能有些属性在堆区开辟了空间。
7.综上：
  使用多态技术 也一定使用虚构（纯虚构）析构。
  virtual在声明和定义中出现一次即可
  使用多态技术 可以使用纯虚函数连用。
/*-------------------------------------------------------------------------------------------------------------*/

    